<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph Visualizer</title>
    <!-- Dependencies -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <style>
        :root {
            /* Color Palette - Light Theme (Start with backup defaults) */
            --bg-primary: oklch(0.96 0 0);
            --bg-secondary: oklch(0.97 0 0);
            --border-light: oklch(0.86 0 0);
            --text-primary: oklch(0.32 0 0);
            --text-secondary: oklch(0.51 0 0);
            --node-default: rgba(59, 130, 246, 0.7);
            --node-anchor: rgba(239, 68, 68, 0.8);
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        /* Dark Theme - Default */
        .dark {
            --bg-primary: oklch(0.22 0 0);
            --bg-secondary: oklch(0.24 0 0);
            --border-light: oklch(0.33 0 0);
            --text-primary: oklch(0.89 0 0);
            --text-secondary: oklch(0.6 0 0);
            --card-bg: oklch(0.24 0 0);
            --card-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            --button-bg: oklch(0.31 0 0);
            --button-hover: oklch(0.37 0 0);
            --accent: oklch(0.37 0 0);
        }

        body { 
            margin: 0; 
            font-family: 'Inter', system-ui, -apple-system, sans-serif; 
            background: var(--bg-primary); 
            color: var(--text-primary); 
            overflow: hidden; 
            -webkit-user-select: none; /* Safari / iOS support */
            user-select: none;
        }

        #app { width: 100vw; height: 100vh; position: relative; }
        
        /* Canvas */
        canvas { 
            position: absolute; top: 0; left: 0; z-index: 1; cursor: grab; 
            background-color: var(--bg-primary);
            background-image: radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.05) 1px, transparent 0);
            background-size: 20px 20px;
        }
        canvas:active { cursor: grabbing; }

        /* General UI Card */
        .ui-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            box-shadow: var(--card-shadow);
            z-index: 100;
            position: absolute;
            -webkit-backdrop-filter: blur(10px); /* Safari / iOS support */
            backdrop-filter: blur(10px);
            padding: 12px;
            color: var(--text-primary);
            font-size: 14px;
        }

        /* Top Center Title */
        .top-center {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            min-width: 300px;
        }
        .top-center h1 { margin: 0; font-size: 16px; font-weight: 600; color: var(--text-primary); }
        .top-center p { margin: 4px 0 0; font-size: 12px; color: var(--text-secondary); }

        /* Top Right: Zoom Controls */
        .top-right {
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }
        .zoom-btn {
            width: 36px; height: 36px;
            background: var(--button-bg);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 18px;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }
        .zoom-btn:hover { background: var(--button-hover); }
        .theme-toggle-btn .theme-icon { display: block; }
        .theme-toggle-btn .theme-icon-moon { stroke: #f59e0b; }

        /* Bottom Right Upper: Legend */
        .bottom-right-upper {
            bottom: 240px; /* Slightly lower to add space from zoom controls */
            right: 20px;
            width: 200px;
            max-height: 300px;
            overflow-y: auto;
        }

        /* Bottom Right Lower: Controls */
        .bottom-right-lower {
            bottom: 20px;
            right: 20px;
            width: 180px;
        }

        .section-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-light);
            padding-bottom: 8px;
            margin-bottom: 12px;
        }
        .sub-header { 
            font-size: 12px; 
            font-weight: 600; 
            color: var(--text-secondary); 
            text-transform: uppercase; 
            letter-spacing: 0.5px;
            margin-bottom: 8px; 
        }

        /* Legend Items */
        .legend-list { display: flex; flex-direction: column; gap: 6px; margin-bottom: 16px; }
        .legend-item { display: flex; align-items: center; gap: 10px; font-size: 12px; }
        .swatch { 
            width: 18px; height: 18px; 
            border-radius: 4px; 
            border: 1px solid var(--border-light);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            flex-shrink: 0; 
        }

        /* Toggles */
        .toggle-row { display: flex; flex-direction: column; gap: 6px; margin-bottom: 12px; }
        .toggle-row label { font-size: 12px; font-weight: 500; color: var(--text-secondary); }
        .switch { position: relative; width: 44px; height: 24px; display: inline-block; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; bottom: 0; left: 0; right: 0; background-color: #2b3137; transition: .3s; border-radius: 24px; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: var(--bg-secondary); transition: .3s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--node-default); }
        input:checked + .slider:before { transform: translateX(20px); }

        /* Buttons */
        .grid-buttons { display: flex; gap: 8px; }
        .btn-action {
            flex: 1;
            background: var(--button-bg);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: 0.2s;
        }
        .btn-action:hover { background: var(--button-hover); }

        /* Context Menu */
        #context-menu {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            box-shadow: var(--card-shadow);
            z-index: 2000;
            padding: 4px 0;
            min-width: 140px;
        }
        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-primary);
            transition: background 0.2s;
        }
        .context-menu-item:hover { background: var(--button-hover); }

        /* Chat Widget Styles */
        .chat-trigger {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 14px rgba(0,0,0,0.25);
            z-index: 2000;
            transition: transform 0.2s;
        }
        .chat-trigger:hover { transform: scale(1.1); }

        .chat-container {
            position: fixed;
            bottom: 80px;
            left: 20px;
            width: 350px;
            height: 500px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            border-radius: 16px;
            border: 1px solid var(--border-light);
            z-index: 2000;
            background: var(--bg-secondary);
        }
        .chat-header {
            background: linear-gradient(to right, #5b21b6 0%, #7c3aed 40%, #a78bfa 100%);
            color: white;
            padding: 16px;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .chat-main {
            flex: 1;
            background: var(--bg-secondary);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .api-key-box {
            padding: 8px 16px;
            background: var(--button-bg);
            border-bottom: 1px solid var(--border-light);
        }
        .api-input {
            width: 100%;
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: 4px;
            padding: 6px 10px;
            color: var(--text-primary);
            font-size: 12px;
            outline: none;
            box-sizing: border-box;
        }

        .messages-area {
            flex: 1;
            padding: 24px 16px 16px 16px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .message-bubble { 
            padding: 10px 14px; 
            border-radius: 12px; 
            font-size: 14px; 
            line-height: 1.5; 
            max-width: 85%; 
        }
        .message-bubble.ai { 
            background: rgba(255, 255, 255, 0.05); 
            border: 1px solid var(--border-light); 
            color: var(--text-primary); 
            align-self: flex-start; 
            border-bottom-left-radius: 2px;
        }
        .message-bubble.user { 
            background: #ffffff; 
            color: #111827; 
            align-self: flex-end; 
            border-bottom-right-radius: 2px;
        }

        .chat-input-bar {
            padding: 12px;
            border-top: 1px solid var(--border-light);
            display: flex;
            gap: 8px;
            background: var(--bg-secondary);
        }
        .chat-field {
            flex: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border-light);
            border-radius: 20px;
            padding: 10px 16px;
            color: var(--text-primary);
            font-size: 14px;
            outline: none;
        }
        .send-icon-btn {
            width: 38px;
            height: 38px;
            background: white;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: black;
        }

        .fade-slide-enter-active, .fade-slide-leave-active { transition: all 0.3s ease; }
        .fade-slide-enter-from, .fade-slide-leave-to { opacity: 0; transform: translateY(20px) scale(0.9); }

        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-thumb { background: #30363d; border-radius: 10px; }
    </style>
</head>
<body>
    <div id="app">
        <!-- Canvas -->
        <canvas ref="canvasEl" 
            @mousedown="handleMouseDown" 
            @mousemove="handleMouseMove" 
            @mouseup="handleMouseUp" 
            @wheel.prevent="handleWheel"
            @contextmenu.prevent="handleRightClick">
        </canvas>

        <!-- Context Menu -->
        <div id="context-menu" v-if="contextMenu.visible" :style="{ top: contextMenu.y + 'px', left: contextMenu.x + 'px' }">
            <template v-if="isolatedNode && isolatedNode.id === contextMenu.node?.id">
                 <div class="context-menu-item" @click="cancelIsolation">Cancel Isolation</div>
            </template>
            <template v-else>
                <div class="context-menu-item" @click="isolateNode">Isolate Node</div>
            </template>
            <div class="context-menu-item" @click="copyLabel">Copy Label</div>
        </div>
        
        <!-- Header -->
        <div class="ui-card top-center">
            <h1>{{ metadata.title || 'Directed Graph with Anchors' }}</h1>
            <p>{{ metadata.nodeCount }} nodes ({{ legend.nodeTypes.length }} types), {{ metadata.edgeCount }} edges ({{ legend.edgeTypes ? legend.edgeTypes.length : (raw && raw.edges ? 1 : 0) }} types)</p>
        </div>

        <!-- Zoom Controls + Dark/Light Toggle -->
        <div class="ui-card top-right">
            <button class="zoom-btn" @click="changeZoom(1.1)" aria-label="Zoom in" title="Zoom in">+</button>
            <button class="zoom-btn" @click="changeZoom(0.9)" aria-label="Zoom out" title="Zoom out">−</button>
            <button class="zoom-btn" @click="resetCamera" aria-label="Center view" title="Center view">⌂</button>
            <button class="zoom-btn theme-toggle-btn" @click="toggleTheme" aria-label="Toggle dark or light mode" title="Toggle dark or light mode">
                <svg v-if="isDark" class="theme-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
                <svg v-else class="theme-icon theme-icon-moon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
            </button>
        </div>

        <!-- Legend Card (Fixed Bottom Right Upper) -->
        <div class="ui-card bottom-right-upper">
            <div class="section-title">Legend</div>
            <div class="sub-header">NODE TYPES</div>
            <div class="legend-list">
                <div v-for="t in legend.nodeTypes" :key="t.label" class="legend-item">
                    <div class="swatch" :style="{ background: t.color }"></div>
                    <span>{{ t.label }}</span>
                </div>
            </div>
            <div class="sub-header" v-if="legend.edgeTypes && legend.edgeTypes.length > 0">EDGE TYPES</div>
            <div class="legend-list" v-if="legend.edgeTypes && legend.edgeTypes.length > 0">
                <div v-for="t in legend.edgeTypes" :key="t.label" class="legend-item">
                    <div class="swatch" :style="{ background: t.color, height: '4px', marginTop: '7px' }"></div>
                    <span>{{ t.label }}</span>
                </div>
            </div>
            <div class="sub-header">SPECIAL NODES</div>
            <div class="legend-item">
                <div class="swatch" style="background: rgba(248, 113, 113, 0.9);"></div>
                <span>Anchor Nodes</span>
            </div>
        </div>

        <!-- Controls Card (Fixed Bottom Right Lower) -->
        <div class="ui-card bottom-right-lower">
            <div class="toggle-row">
                <label>Show Labels</label>
                <label class="switch">
                    <input
                        type="checkbox"
                        v-model="showLabels"
                        @change="render"
                        aria-label="Toggle node labels">
                    <span class="slider"></span>
                </label>
            </div>
            <!-- Navigation -->
            <div class="toggle-row">
                <label>Navigation</label>
                <div class="grid-buttons">
                    <button class="btn-action" @click="nav('http://localhost:3000/import')">Upload</button>
                    <button class="btn-action" @click="nav('http://localhost:3000')">Annotation</button>
                </div>
            </div>
             <!-- Export -->
             <div class="toggle-row">
                <label>Export</label>
                <div class="grid-buttons">
                    <button class="btn-action" @click="savePDF">PDF</button>
                    <button class="btn-action" @click="savePNG">PNG</button>
                </div>
            </div>
        </div>

        <!-- Chat -->
        <div class="chat-trigger" @click="openChat = !openChat">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
        </div>

        <transition name="fade-slide">
            <div v-if="openChat" class="chat-container">
                <div class="chat-header">
                    <span>Pattern Analyser</span>
                    <span @click="openChat = false" style="cursor: pointer; opacity: 0.8;">×</span>
                </div>
                <div class="chat-main">
                    <div class="api-key-box">
                    <input
                        type="password"
                        v-model="geminiApiKey"
                        class="api-input"
                        placeholder="Enter Gemini API Key"
                        aria-label="Gemini API key">
                    </div>
                    <div class="messages-area" ref="scrollRef">
                        <div v-for="m in chats" :key="m.id" :class="['message-bubble', m.role]">
                            {{ m.text }}
                        </div>
                    </div>
                </div>
                <div class="chat-input-bar">
                    <input
                        v-model="query"
                        @keyup.enter="doChat"
                        class="chat-field"
                        placeholder="Ask about this pattern..."
                        aria-label="Pattern Analyser message">
                    <button
                        class="send-icon-btn"
                        @click="doChat"
                        aria-label="Send message"
                        title="Send message">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="black" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
                    </button>
                </div>
            </div>
        </transition>
    </div>

    <script>
        const GRAPH_DATA = null;

        const { createApp, ref, onMounted, nextTick, reactive } = Vue;

        class LayoutEngine {
            static computeLayout(nodes, edges) {
                const adj = {};
                const degree = {};
                nodes.forEach(n => { adj[n.id] = []; degree[n.id] = 0; });
                edges.forEach(e => {
                    if (adj[e.source] && adj[e.target]) {
                        adj[e.source].push(e.target);
                        if (!adj[e.target].includes(e.source)) adj[e.target].push(e.source);
                        degree[e.source]++; degree[e.target]++;
                    }
                });
                let centerNodeId = nodes[0]?.id;
                let maxDeg = -1;
                for (let id in degree) { if(degree[id] > maxDeg) { maxDeg = degree[id]; centerNodeId = id; } }
                
                const layers = {};
                const q = [{id: centerNodeId, d: 0}];
                const visited = new Set([centerNodeId]);
                while(q.length) {
                    const cur = q.shift();
                    if(!layers[cur.d]) layers[cur.d] = [];
                    layers[cur.d].push(cur.id);
                    (adj[cur.id] || []).forEach(nId => {
                        if(!visited.has(nId)) {
                            visited.add(nId);
                            q.push({id: nId, d: cur.d+1});
                        }
                    });
                }
                const pos = {};
                const baseRad = 250;
                Object.keys(layers).forEach(d => {
                    const depth = parseInt(d);
                    const levelNodes = layers[d];
                    const radius = depth * baseRad;
                    levelNodes.forEach((nid, i) => {
                        const angle = (2 * Math.PI * i) / levelNodes.length;
                        pos[nid] = { x: radius * Math.cos(angle), y: radius * Math.sin(angle) };
                    });
                });
                nodes.forEach(n => {
                    if(pos[n.id]) { n.x = pos[n.id].x; n.y = pos[n.id].y; }
                    else { n.x = 0; n.y = 0; }
                });
            }
        }

        const generateColor = (seed) => {
            const hue = (seed * 137.508) % 360;
            const saturation = 50 + (seed * 19) % 25; 
            const lightness = 65 + (seed * 13) % 20; 
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        };

        createApp({
            setup() {
                const canvasEl = ref(null);
                const scrollRef = ref(null);
                const openChat = ref(false);
                const showLabels = ref(true);
                const isDark = ref(true);
                const query = ref('');
                const geminiApiKey = ref('');
                const isolatedNode = ref(null);
                const selectedNode = ref(null);
                
                const raw = GRAPH_DATA || {
                    metadata: { title: "No Data", nodeCount: 0, edgeCount: 0 },
                    nodes: [], edges: [], legend: { nodeTypes: [], edgeTypes: [] }
                };

                if (raw.nodes.length > 0 && raw.legend.nodeTypes.length === 0) {
                    const types = new Set();
                    raw.nodes.forEach(n => { if (n.label && !n.anchor) types.add(n.label); });
                    let seed = 0;
                    types.forEach(t => {
                        raw.legend.nodeTypes.push({ label: t, color: generateColor(seed++) });
                    });
                } else if (raw.legend.nodeTypes.length > 0) {
                    // Ensure anchors are excluded from legend if pre-populated
                    const anchorLabels = new Set(raw.nodes.filter(n => n.anchor).map(n => n.label));
                    raw.legend.nodeTypes = raw.legend.nodeTypes.filter(t => !anchorLabels.has(t.label));
                }

                // Auto-generate Edge Legend if missing
                if (raw.edges.length > 0 && (!raw.legend.edgeTypes || raw.legend.edgeTypes.length === 0)) {
                    if (!raw.legend.edgeTypes) raw.legend.edgeTypes = [];
                    const eTypes = new Set();
                    raw.edges.forEach(e => { if (e.label) eTypes.add(e.label); });
                    let seed = 100; // Different seed for edges
                    eTypes.forEach(t => {
                        raw.legend.edgeTypes.push({ label: t, color: '#3b82f6' }); // Default blue for edges
                    });
                }

                if (raw.nodes.length > 0) LayoutEngine.computeLayout(raw.nodes, raw.edges);

                const metadata = ref(raw.metadata);
                const legend = ref(raw.legend);
                const chats = ref([{ id: 1, role: 'ai', text: "Hello! I'm your Pattern Analyst. I can help you understand the topological structure of this motif. Ask me anything!" }]);
                
                const contextMenu = reactive({ visible: false, x: 0, y: 0, node: null });

                let ctx;
                let cam = { x: 0, y: 0, k: 1 };
                let isDragging = false;
                let draggedNode = null;
                let lastMouse = { x: 0, y: 0 };
                let hoveredNode = null;

                const getWorldPos = (ex, ey) => {
                    const canvas = canvasEl.value;
                    const wx = (ex - canvas.width/2 - cam.x) / cam.k;
                    const wy = (ey - canvas.height/2 - cam.y) / cam.k;
                    return { x: wx, y: wy };
                };

                const getNodeAt = (wx, wy) => {
                    for (let i = raw.nodes.length - 1; i >= 0; i--) {
                        const n = raw.nodes[i];
                        const r = n.anchor ? 58 : 50;
                        const dist = Math.sqrt((n.x - wx)**2 + (n.y - wy)**2);
                        if (dist < r) return n;
                    }
                    return null;
                };

                const render = () => {
                    const canvas = canvasEl.value;
                    if (!canvas || !ctx) return;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.save();
                    ctx.translate(canvas.width/2 + cam.x, canvas.height/2 + cam.y);
                    ctx.scale(cam.k, cam.k);

                    const iso = isolatedNode.value;

                    // Edges
                    raw.edges.forEach(e => {
                        const s = raw.nodes.find(n => n.id === e.source);
                        const t = raw.nodes.find(n => n.id === e.target);
                        if (!s || !t) return;

                        let isDimmed = false;
                        if (iso) {
                            const connected = (s.id === iso.id || t.id === iso.id);
                            if (!connected) isDimmed = true;
                        }

                        ctx.globalAlpha = isDimmed ? 0.1 : 0.8;
                        ctx.strokeStyle = isDimmed ? '#555' : '#3b82f6';
                        ctx.lineWidth = 2.5; 

                        const sr = s.anchor ? 58 : 50;
                        const tr = t.anchor ? 58 : 50;
                        
                        const dx = t.x - s.x;
                        const dy = t.y - s.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (dist === 0) return;

                        // Calculate intersection points at node boundaries
                        const ux = dx / dist;
                        const uy = dy / dist;
                        
                        const sx = s.x + ux * sr;
                        const sy = s.y + uy * sr;
                        const tx = t.x - ux * tr;
                        const ty = t.y - uy * tr;

                        ctx.beginPath();
                        ctx.moveTo(sx, sy);
                        ctx.lineTo(tx, ty);
                        ctx.stroke();

                        if (e.directed) {
                            const angle = Math.atan2(dy, dx);
                            // Arrowhead at the exact boundary point (tx, ty)
                            ctx.fillStyle = ctx.strokeStyle;
                            ctx.beginPath();
                            ctx.moveTo(tx, ty);
                            ctx.lineTo(tx - 10*Math.cos(angle - 0.4), ty - 10*Math.sin(angle - 0.4));
                            ctx.lineTo(tx - 10*Math.cos(angle + 0.4), ty - 10*Math.sin(angle + 0.4));
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        if (showLabels.value && e.label && e.label !== 'default' && !isDimmed) {
                            drawLabelBox(e.label, (s.x+t.x)/2, (s.y+t.y)/2, 10, false);
                        }
                    });

                    // Nodes
                    raw.nodes.forEach(n => {
                        let isDimmed = false;
                        if (iso) {
                            const isNeighbor = raw.edges.some(e => 
                                (e.source === iso.id && e.target === n.id) || 
                                (e.target === iso.id && e.source === n.id)
                            );
                            if (n.id !== iso.id && !isNeighbor) isDimmed = true;
                        }

                        const isAnchor = n.anchor;
                        const r = isAnchor ? 58 : 50; // Updated sizes
                        
                        ctx.save();
                        ctx.globalAlpha = isDimmed ? 0.2 : 1.0;
                        
                        // Stroke Logic: Only show blue border on Hover or Selection
                        const isSelected = selectedNode.value && selectedNode.value.id === n.id;
                        const isHovered = hoveredNode && hoveredNode.id === n.id;
                        
                        if (isSelected || isHovered) {
                            ctx.strokeStyle = '#3b82f6';
                            ctx.lineWidth = 3;
                        } else {
                            ctx.strokeStyle = 'transparent'; // No border by default
                            ctx.lineWidth = 0;
                        }
                        
                        const fill = isAnchor ? 'rgba(239, 68, 68, 0.9)' : 
                                    (legend.value.nodeTypes.find(t => t.label === n.label)?.color || 'rgba(96, 165, 250, 0.8)');
                        
                        ctx.fillStyle = fill;
                        ctx.beginPath();
                        if (isAnchor) ctx.rect(n.x - r, n.y - r, r*2, r*2);
                        else ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if (isSelected || isHovered) {
                            ctx.stroke();
                        }
                        
                        ctx.restore();

                        if (showLabels.value && !isDimmed) {
                            drawLabelBox(`label: ${n.label || 'Node'}`, n.x, n.y, 12, true);
                        }
                    });
                    ctx.restore();
                };

                const drawLabelBox = (text, x, y, fontSize, isNode) => {
                    ctx.save();
                    ctx.globalAlpha = 1.0; // Ensure opacity
                    ctx.font = `${fontSize}px Inter, sans-serif`;
                    const metrics = ctx.measureText(text);
                    const w = metrics.width;
                    const h = fontSize;
                    const p = 4;
                    
                    // PURE WHITE BACKGROUND
                    ctx.fillStyle = '#FFFFFF'; 
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.15)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.roundRect(x - w/2 - p, y - h/2 - p, w + p*2, h + p*2, 4);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Black Text
                    ctx.fillStyle = '#000000';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(text, x, y + 1);
                    ctx.restore();
                };

                // Helper to draw light legend onto an export canvas (for PDF)
                const drawExportLegend = (targetCtx, position, bgColor) => {
                    const canvas = targetCtx.canvas;
                    const padding = 88;
                    const lineHeight = 88;
                    const boxWidth = 800;
                    let x, y;

                    if (position === 'top-right') {
                        x = canvas.width - boxWidth - padding;
                        y = padding;
                    } else if (position === 'bottom-left') {
                        x = padding;
                        y = canvas.height - padding;
                    } else if (position === 'bottom-right') {
                        x = canvas.width - boxWidth - padding;
                        y = canvas.height - padding;
                    } else {
                        x = canvas.width - boxWidth - padding;
                        y = padding;
                    }

                    targetCtx.save();
                    targetCtx.font = '56px Inter, sans-serif';

                    // Calculate height
                    let lines = 0;
                    const nodeTypes = legend.value.nodeTypes || [];
                    const edgeTypes = legend.value.edgeTypes || [];

                    lines += 1; // "Legend"
                    if (nodeTypes.length) {
                        lines += 1; // header
                        lines += nodeTypes.length;
                    }
                    if (edgeTypes.length) {
                        lines += 1; // header
                        lines += edgeTypes.length;
                    }
                    lines += 2; // "SPECIAL NODES" + anchor row

                    const boxHeight = padding + lines * lineHeight;
                    if (position === 'bottom-left' || position === 'bottom-right') {
                        y = y - boxHeight;
                    }

                    // Background + border
                    targetCtx.fillStyle = bgColor;
                    targetCtx.strokeStyle = '#000000';
                    // Make PDF legend border thick and clear
                    targetCtx.lineWidth = 4;
                    targetCtx.beginPath();
                    targetCtx.roundRect(x, y, boxWidth, boxHeight, 8);
                    targetCtx.fill();
                    targetCtx.stroke();

                    // Text and swatches
                    let cursorY = y + padding;
                    const textX = x + 12;

                    targetCtx.fillStyle = '#111827';
                    targetCtx.fillText('Legend', textX, cursorY);
                    cursorY += lineHeight;

                    if (nodeTypes.length) {
                        targetCtx.fillStyle = '#6b7280';
                        targetCtx.fillText('NODE TYPES', textX, cursorY);
                        cursorY += lineHeight;
                        nodeTypes.forEach(t => {
                            // Larger swatch square for node type color
                            targetCtx.fillStyle = t.color || '#3b82f6';
                            targetCtx.strokeStyle = 'rgba(0,0,0,0.12)';
                            targetCtx.beginPath();
                            targetCtx.roundRect(x + 12, cursorY - 22, 32, 32, 6);
                            targetCtx.fill();
                            targetCtx.stroke();

                            // label
                            targetCtx.fillStyle = '#111827';
                            targetCtx.fillText(t.label, textX + 24, cursorY);
                            cursorY += lineHeight;
                        });
                    }

                    if (edgeTypes.length) {
                        targetCtx.fillStyle = '#6b7280';
                        targetCtx.fillText('EDGE TYPES', textX, cursorY);
                        cursorY += lineHeight;
                        edgeTypes.forEach(t => {
                            // Larger edge swatch bar
                            targetCtx.fillStyle = t.color || '#3b82f6';
                            targetCtx.fillRect(x + 12, cursorY - 10, 64, 8);
                            targetCtx.fillStyle = '#111827';
                            targetCtx.fillText(t.label, textX + 32, cursorY);
                            cursorY += lineHeight;
                        });
                    }

                    targetCtx.fillStyle = '#6b7280';
                    targetCtx.fillText('SPECIAL NODES', textX, cursorY);
                    cursorY += lineHeight;

                    // Anchor row with larger swatch
                    targetCtx.fillStyle = 'rgba(248, 113, 113, 0.9)';
                    targetCtx.strokeStyle = 'rgba(0,0,0,0.12)';
                    targetCtx.beginPath();
                    targetCtx.roundRect(x + 12, cursorY - 22, 32, 32, 6);
                    targetCtx.fill();
                    targetCtx.stroke();
                    targetCtx.fillStyle = '#111827';
                    targetCtx.fillText('Anchor Nodes', textX + 24, cursorY);

                    targetCtx.restore();
                };

                // Helper to draw PNG legend (bottom-right), layout similar to on-screen legend card, scaled up ~4x
                const drawExportLegendDark = (targetCtx) => {
                    const canvas = targetCtx.canvas;
                    const padding = 88;
                    const lineHeight = 88;
                    const boxWidth = 800; 
                    let x = canvas.width - boxWidth - padding;
                    let y = canvas.height - padding;

                    targetCtx.save();
                    targetCtx.font = '56px Inter, sans-serif';

                    // Calculate height
                    let lines = 0;
                    const nodeTypes = legend.value.nodeTypes || [];
                    const edgeTypes = legend.value.edgeTypes || [];

                    lines += 1; // "Legend"
                    if (nodeTypes.length) {
                        lines += 1; // header
                        lines += nodeTypes.length;
                    }
                    if (edgeTypes.length) {
                        lines += 1; // header
                        lines += edgeTypes.length;
                    }
                    lines += 2; // "SPECIAL NODES" + anchor row

                    const boxHeight = padding + lines * lineHeight;
                    y = y - boxHeight;

                    // Dark legend card background & subtle border, similar to UI
                    targetCtx.fillStyle = '#111827';
                    targetCtx.strokeStyle = '#4b5563';
                    targetCtx.lineWidth = 1.5;
                    targetCtx.beginPath();
                    targetCtx.roundRect(x, y, boxWidth, boxHeight, 14);
                    targetCtx.fill();
                    targetCtx.stroke();

                    // Text and swatches
                    let cursorY = y + padding;
                    const textX = x + 12;

                    targetCtx.fillStyle = '#e5e7eb';
                    targetCtx.fillText('Legend', textX, cursorY);
                    cursorY += lineHeight;

                    if (nodeTypes.length) {
                        targetCtx.fillStyle = '#9ca3af';
                        targetCtx.fillText('Node Types', textX, cursorY);
                        cursorY += lineHeight;
                        nodeTypes.forEach(t => {
                            // Larger swatch square for node type color
                            targetCtx.fillStyle = t.color || '#3b82f6';
                            targetCtx.beginPath();
                            targetCtx.roundRect(x + 16, cursorY - 22, 32, 32, 6);
                            targetCtx.fill();

                            // label
                            targetCtx.fillStyle = '#e5e7eb';
                            targetCtx.fillText(t.label, textX + 24, cursorY);
                            cursorY += lineHeight;
                        });
                    }

                    if (edgeTypes.length) {
                        targetCtx.fillStyle = '#9ca3af';
                        targetCtx.fillText('Edge Types', textX, cursorY);
                        cursorY += lineHeight;
                        edgeTypes.forEach(t => {
                            // Larger edge swatch bar
                            targetCtx.fillStyle = t.color || '#3b82f6';
                            targetCtx.fillRect(x + 16, cursorY - 10, 64, 8);
                            targetCtx.fillStyle = '#e5e7eb';
                            targetCtx.fillText(t.label, textX + 32, cursorY);
                            cursorY += lineHeight;
                        });
                    }

                    targetCtx.fillStyle = '#9ca3af';
                    targetCtx.fillText('Special Nodes', textX, cursorY);
                    cursorY += lineHeight;

                    // Anchor row with larger swatch
                    targetCtx.fillStyle = 'rgba(248, 113, 113, 0.9)';
                    targetCtx.beginPath();
                    targetCtx.roundRect(x + 16, cursorY - 22, 32, 32, 6);
                    targetCtx.fill();
                    targetCtx.fillStyle = '#e5e7eb';
                    targetCtx.fillText('Anchor Nodes', textX + 24, cursorY);

                    targetCtx.restore();
                };

                // Mouse Event Handlers
                const handleMouseDown = (e) => {
                    if (e.button !== 0) return; // Only left click
                    contextMenu.visible = false;
                    const { x, y } = getWorldPos(e.clientX, e.clientY);
                    const node = getNodeAt(x, y);
                    
                    // Selection Logic
                    selectedNode.value = node; // Set selected node (or null if bg clicked)
                    
                    if (node) draggedNode = node;
                    else isDragging = true;
                    lastMouse = { x: e.clientX, y: e.clientY };
                    render();
                };

                const handleMouseMove = (e) => {
                    const { x, y } = getWorldPos(e.clientX, e.clientY);
                    if (draggedNode) {
                        draggedNode.x = x;
                        draggedNode.y = y;
                        canvasEl.value.style.cursor = 'grabbing';
                    } else if (isDragging) {
                        cam.x += (e.clientX - lastMouse.x);
                        cam.y += (e.clientY - lastMouse.y);
                        canvasEl.value.style.cursor = 'grabbing';
                    } else {
                        const node = getNodeAt(x, y);
                        hoveredNode = node;
                        canvasEl.value.style.cursor = node ? 'pointer' : 'grab';
                    }
                    lastMouse = { x: e.clientX, y: e.clientY };
                    render();
                };

                const handleMouseUp = () => { draggedNode = null; isDragging = false; render(); };
                const handleWheel = (e) => {
                    const f = e.deltaY > 0 ? 0.9 : 1.1;
                    cam.k *= f;
                    render();
                };
                
                const handleRightClick = (e) => {
                    const { x, y } = getWorldPos(e.clientX, e.clientY);
                    const node = getNodeAt(x, y);
                    if (node) {
                        contextMenu.visible = true;
                        contextMenu.x = e.clientX;
                        contextMenu.y = e.clientY;
                        contextMenu.node = node;
                        // Right click also selects? Usually convenient.
                        selectedNode.value = node;
                        render();
                    }
                };

                // Context Actions
                const isolateNode = () => {
                    isolatedNode.value = contextMenu.node;
                    contextMenu.visible = false;
                    render();
                };
                const cancelIsolation = () => {
                    isolatedNode.value = null;
                    contextMenu.visible = false;
                    render();
                };
                const copyLabel = () => {
                   if (contextMenu.node && contextMenu.node.label) {
                       navigator.clipboard.writeText(contextMenu.node.label);
                       alert("Label copied: " + contextMenu.node.label);
                   }
                   contextMenu.visible = false;
                };

                const changeZoom = (f) => { cam.k *= f; render(); };
                const resetCamera = () => { cam = { x: 0, y: 0, k: 1 }; render(); };
                const toggleTheme = () => {
                    isDark.value = !isDark.value;
                    document.documentElement.className = isDark.value ? 'dark' : '';
                    render();
                };
                
                const doChat = async () => {
                    const t = query.value.trim();
                    if (!t) return;
                    chats.value.push({ id: Date.now(), role: 'user', text: t });
                    query.value = '';
                    nextTick(() => scrollRef.value.scrollTop = scrollRef.value.scrollHeight);
                    try {
                        const res = await fetch(`http://localhost:${GRAPH_DATA?.CHAT_PORT || 9002}/chat`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ message: t, graph_data: raw, api_key: geminiApiKey.value })
                        });
                        const data = await res.json();
                        chats.value.push({ id: Date.now(), role: 'ai', text: data.response || "No response." });
                    } catch (e) {
                         chats.value.push({
                            id: Date.now(),
                            role: 'ai',
                            text: "I apologize, but I encountered an error connecting to the analysis server. Please ensure the backend is running."
                         });
                    }
                    nextTick(() => scrollRef.value.scrollTop = scrollRef.value.scrollHeight);
                };

                const savePDF = () => {
                    const sourceCanvas = canvasEl.value;
                    if (!sourceCanvas) return;

                    // Create a very high-resolution offscreen canvas for clarity
                    const scale = 4;
                    const exportCanvas = document.createElement('canvas');
                    exportCanvas.width = sourceCanvas.width * scale;
                    exportCanvas.height = sourceCanvas.height * scale;
                    const exportCtx = exportCanvas.getContext('2d');

                    // White background for PDF (full page)
                    exportCtx.fillStyle = '#ffffff';
                    exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

                    // Draw the main canvas scaled
                    exportCtx.drawImage(
                        sourceCanvas,
                        0,
                        0,
                        sourceCanvas.width,
                        sourceCanvas.height,
                        0,
                        0,
                        exportCanvas.width,
                        exportCanvas.height
                    );

                    // Draw legend in the top-right corner
                    drawExportLegend(exportCtx, 'top-right', '#ffffff');

                    const imgData = exportCanvas.toDataURL('image/png');
                    const doc = new window.jspdf.jsPDF('l', 'px', [exportCanvas.width, exportCanvas.height]);
                    doc.addImage(imgData, 'PNG', 0, 0, exportCanvas.width, exportCanvas.height);
                    const suffix = Date.now();
                    doc.save(`graph_visualization_${suffix}.pdf`);
                };

                const savePNG = () => {
                    const sourceCanvas = canvasEl.value;
                    if (!sourceCanvas) return;

                    const exportCanvas = document.createElement('canvas');
                    exportCanvas.width = sourceCanvas.width * 4;
                    exportCanvas.height = sourceCanvas.height * 4;
                    const exportCtx = exportCanvas.getContext('2d');

                    // White background for PNG as requested
                    exportCtx.fillStyle = '#ffffff';
                    exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

                    // Draw the main canvas scaled up for clarity
                    exportCtx.drawImage(
                        sourceCanvas,
                        0,
                        0,
                        sourceCanvas.width,
                        sourceCanvas.height,
                        0,
                        0,
                        exportCanvas.width,
                        exportCanvas.height
                    );

                    // Draw dark legend in the bottom-right corner (matching on-screen card)
                    drawExportLegendDark(exportCtx);

                    const link = document.createElement('a');
                    const suffix = Date.now();
                    link.download = `graph_visualization_${suffix}.png`;
                    link.href = exportCanvas.toDataURL('image/png');
                    link.click();
                };
                const nav = (u) => window.open(u, '_blank');

                onMounted(() => {
                    document.documentElement.className = isDark.value ? 'dark' : '';
                    const c = canvasEl.value;
                    c.width = window.innerWidth;
                    c.height = window.innerHeight;
                    ctx = c.getContext('2d');
                    window.addEventListener('resize', () => { c.width = window.innerWidth; c.height = window.innerHeight; render(); });
                    document.addEventListener('click', (e) => { if (!e.target.closest('#context-menu')) contextMenu.visible = false; });
                    render();
                });

                return {
                    canvasEl, scrollRef, openChat, showLabels, query, geminiApiKey, metadata, legend, chats,
                    isDark, toggleTheme, changeZoom, resetCamera, handleMouseDown, handleMouseMove, handleMouseUp, handleWheel, handleRightClick,
                    contextMenu, isolateNode, cancelIsolation, copyLabel, isolatedNode,
                    doChat, savePDF, savePNG, nav, render
                };
            }
        }).mount('#app');
    </script>
</body>
</html>